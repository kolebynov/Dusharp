using System.Text;
using Dusharp.SourceGenerator.Common.Extensions;

namespace Dusharp.SourceGenerator.Common;

public sealed class CodeWriter : IDisposable
{
#pragma warning disable RS1035
	private static readonly string NewLine = Environment.NewLine;
#pragma warning restore RS1035

	private readonly bool _writeSemicolonOnClose;
	private readonly StringBuilder _stringBuilder;
	private int _depth;
	private string _depthStr = null!;

	public CodeWriter AppendLine() => AppendLineWithoutTab(string.Empty);

	public CodeWriter()
		: this(new StringBuilder(), 0, false)
	{
	}

	public CodeWriter AppendLine(string line) => Append(_depthStr, line, true);

	public CodeWriter Append(string? line) => Append(_depthStr, line, false);

	public CodeWriter Append<T>(T value) => Append(value!.ToString());

	public CodeWriter AppendLineWithoutTab(string line) => Append(string.Empty, line, true);

	public CodeWriter NewBlock(bool writeSemicolonOnClose = false)
	{
		AppendLine("{");
		return new CodeWriter(_stringBuilder, _depth + 1, writeSemicolonOnClose);
	}

	public IncreasedDepth IncreaseDepth()
	{
		SetDepth(_depth + 1);
		return new IncreasedDepth(this);
	}

	public void Dispose()
	{
		if (_depth > 0)
		{
			Append(new string('\t', _depth - 1), _writeSemicolonOnClose ? "};" : "}", true);
		}
	}

	public override string ToString() => _stringBuilder.ToString();

	public static CodeWriter CreateWithDefaultLines() =>
		new CodeWriter()
			.AppendLine("// <auto-generated> This file has been auto generated. </auto-generated>")
			.AppendLine("#nullable enable");

	private CodeWriter(StringBuilder stringBuilder, int depth, bool writeSemicolonOnClose)
	{
		_stringBuilder = stringBuilder;
		_writeSemicolonOnClose = writeSemicolonOnClose;
		SetDepth(depth);
	}

	private CodeWriter Append(string depthStr, string? line, bool newLine)
	{
		if (_stringBuilder.Length > 0 && line != "}" && _stringBuilder[^(NewLine.Length + 1)] == '}' && _stringBuilder[^(NewLine.Length + 2)] is '\n' or '\t')
		{
			_stringBuilder.AppendLine();
		}

		if (_stringBuilder.EndsWith(NewLine) && depthStr.Length > 0)
		{
			_stringBuilder.Append(depthStr);
		}

		_stringBuilder.Append(line);
		if (newLine)
		{
			_stringBuilder.AppendLine();
		}

		return this;
	}

	private void SetDepth(int depth)
	{
		_depth = depth;
		_depthStr = new string('\t', depth);
	}

	public readonly struct IncreasedDepth : IDisposable
	{
		private readonly CodeWriter _codeWriter;

		public IncreasedDepth(CodeWriter codeWriter)
		{
			_codeWriter = codeWriter;
		}

		public void Dispose()
		{
			_codeWriter.SetDepth(_codeWriter._depth - 1);
		}
	}
}